{% extends "blog/article.html" %}
{% load static %}
{% block content %}
<h2 id="section-introduction">Introduction</h2>
<p>
This article includes basic data structures and ready-to-use C++ implementations. More detailed explanations can be found in the <a href="https://mitpress.mit.edu/books/introduction-algorithms">'Introduction to Algorithms'</a> book.
</p>
<hr>
<h2 id="section-stack">Stack</h2>
<p>Stacks are dynamic sets that implement a <strong>last-in, first-out (LIFO)</strong> policy. Imagine a spring loaded dish stack accessible only from the top. It always <strong>pops</strong> out the top plate which is <strong>pushed</strong> in last time. After each push/pop, the 'spring' will automatically adjust the <strong>top</strong> plate in the stack.</p>
<br>
<figure>
	<p><img id="img-stack" class="center"></p>
	<figcaption>
	<strong>Fig 1. </strong> (a) Inserting (<strong>push</strong>) data to and removing (<strong>pop</strong>) data from a <strong>stack</strong> is analogous to the dish loading and retrieving from a spring loaded dish stack. (b) Array implementation of stack. Pushing 7 into the stack increases the <strong>head</strong> index. Pop operation decreases it back and outputs the previously inserted 7 (LIFO). 
	</figcaption> 
</figure>
<br>
<h3 id='section-stack-cpp'>stack.cpp</h3>
<div class="code-block" id="user-src-1"></div>
<div class="output-block" id="output-1"></div>
<p>All operations, push/pop and top, of stack take \(O(1)\) time.</p>
<p class="note">To include c++11 using g++ compiler: g++ -std=c++11 stack.cpp </p>
<hr>
<h2 id="section-queue">Queue</h2>
<p>Queue implements a <strong>first-in, first-out (FIFO)</strong> policy analogous to a customer line waiting to pay out in the supermakert. Both the <strong>head</strong> and the <strong>tail</strong> of a queue are adjustable. For insert operation (<strong>enqueue</strong>), the data was put behind the tail. For delete (<strong>dequeue</strong>), data was removed from the head position. As a result, the first inserted data always got retrieved earlier than others (FIFO).</p>
<br>
<figure>
	<p><img id="img-queue" class="center"></p>
	<figcaption>
	<strong>Fig 2. </strong> (a) Inserting (<strong>enqueue</strong>) data to and removing (<strong>dequeue</strong>) data from a <strong>queue</strong>. (b) Array implementation of queue. Enqueuing data into the queue increases the <strong>tail</strong> index while dequeue operation increases the <strong>head</strong> index. The data got retrieved is always the one that sits in the queue for the longest time (FIFO). 
	</figcaption> 
</figure>
<br>
<h3 id='section-queue-cpp'>queue.cpp</h3>
<div class="code-block" id="user-src-2"></div>
<div class="output-block" id="output-2"></div>
<p>Similar to <a class="inline-link" href="#section-stack">stack</a>, all operations, enqueue/dequeue and top on queue take \(O(1)\) time.</p>
<hr>
<h2 id="section-list">List</h2>
<p>List or more precisely, doubly linked list, is a more flexible data structure which can be accessed from any position. Previous <a class="inline-link" href="#section-stack">stack</a> and <a class="inline-link" href="#section-queue">queue</a> implement preallocated array while list implements dynamic allocated nodes and pointers to link them together. Each node in the list contains pointers that point to the previous and the next node.</p>
<br>
<figure>
	<p><img id="img-list" class="center"></p>
	<figcaption>
	<strong>Fig 3. </strong> (a) An example of doubly linked list. (b)A circular, doubly linked list with a <strong>sentinel</strong> (nil). Black arrow points to the next node, blue arrow points to the previous node. 
	</figcaption> 
</figure>
<br>
<h3 id='section-list-cpp'>list.cpp</h3>
<div class="code-block" id="user-src-3"></div>
<div class="output-block" id="output-3"></div>
<p>Inserting/removing from either end of list take \(O(1)\) time. It is also worthwhile to note that in the sample code above, the previous pointer is implemented by <code>std::weak_ptr</code> to resolve cyclic reference problem of <code>std::shared_ptr</code>.</p>
<hr>
<h2 id="section-list-sentinel">List with sentinel</h2>
<p>An additional node (<strong>sentinel</strong>) can be inserted between the head and tail of doubly linked list to form a circular linked list (<strong>Fig 3. (b)</strong>). Sentinel can eliminate the boundary condition check in push and pop operations at the cost of additional space. The additional space cost might not be negligible in the case of large number of short lists. The constant factor speed improvement by sentinel is most obvious in inserting/removing from the middle of the list which is not implemented in the sample code.</p>
<br>
<h3 id='section-list-sentinel-cpp'>list-sentinel.cpp</h3>
<div class="code-block" id="user-src-4"></div>
<div class="output-block" id="output-4"></div>
<br>
<p>The testing code is similar to the <code>list.cpp</code> in normal doubly linked list.</p>
{% endblock %}
{% block articlejs %}
<script src="{% static "blog/js/data-structure.js" %}"></script>
<link href="{% static "blog/css/data-structure.css" %}" rel="stylesheet">
{% endblock %}
